// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  user
  admin
}

enum QuestionType {
  single
}

enum MediaKind {
  image
}

/**
 * Autodecks
 */
enum DeckAutoType {
  FLAGGED
  WRONG
}

model User {
  id              String    @id @default(cuid())
  email           String    @unique
  emailVerifiedAt DateTime?
  name            String
  surname         String
  passwordHash    String
  role            Role      @default(user)
  createdAt       DateTime  @default(now())

  purchases     Purchase[]
  attempts      Attempt[]
  emailTokens   EmailVerification[]
  PasswordReset PasswordReset[]
  questionStats UserQuestionStat[]
  questionStars QuestionStar[]

  // Gegenrelationen
  flags   UserQuestionFlag[]
  decks   Deck[]
  reviews ReviewItem[]
}

model Exam {
  id                     String   @id @default(cuid())
  slug                   String   @unique
  title                  String
  description            String
  priceCents             Int
  isPublished            Boolean  @default(false)
  passPercent            Int      @default(60)
  allowImmediateFeedback Boolean  @default(false)
  createdAt              DateTime @default(now())

  stripeProductId String? @unique
  stripePriceId   String? @unique

  sections  Section[]
  questions Question[]
  purchases Purchase[]
  attempts  Attempt[]
  cases     QuestionCase[]
}

model Section {
  id     String @id @default(cuid())
  examId String
  title  String
  order  Int

  exam      Exam       @relation(fields: [examId], references: [id], onDelete: Cascade)
  questions Question[]

  @@unique([examId, order])
}

model Question {
  id                          String       @id @default(cuid())
  examId                      String
  sectionId                   String?
  type                        QuestionType @default(single)
  stem                        String
  explanation                 String?
  hasImmediateFeedbackAllowed Boolean      @default(false)
  tip                         String?
  order                       Int          @default(0)

  caseId    String?
  case      QuestionCase? @relation(fields: [caseId], references: [id], onDelete: SetNull)
  caseOrder Int?

  exam      Exam               @relation(fields: [examId], references: [id], onDelete: Cascade)
  section   Section?           @relation(fields: [sectionId], references: [id], onDelete: SetNull)
  options   AnswerOption[]
  media     QuestionMedia[]
  answers   AttemptAnswer[]
  userStats UserQuestionStat[]
  stars     QuestionStar[]

  // Gegenrelationen
  flags       UserQuestionFlag[]
  tags        QuestionTag[]
  deckItems   DeckItem[]
  reviewItems ReviewItem[]

  @@index([examId, order])
}

model AnswerOption {
  id          String  @id @default(cuid())
  questionId  String
  text        String
  isCorrect   Boolean @default(false)
  explanation String?
  order       Int     @default(0)

  question Question        @relation(fields: [questionId], references: [id], onDelete: Cascade)
  chosenIn AttemptAnswer[] @relation("AnswerOption_ChosenIn")

  @@index([questionId])
  @@index([questionId, order])
}

model Attempt {
  id           String    @id @default(cuid())
  userId       String
  examId       String
  startedAt    DateTime  @default(now())
  finishedAt   DateTime?
  scorePercent Int?
  passed       Boolean?
  elapsedSec   Int       @default(0)

  user    User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  exam    Exam            @relation(fields: [examId], references: [id], onDelete: Cascade)
  answers AttemptAnswer[]
}

model AttemptAnswer {
  id             String  @id @default(cuid())
  attemptId      String
  questionId     String
  answerOptionId String
  isCorrect      Boolean

  attempt      Attempt      @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  question     Question     @relation(fields: [questionId], references: [id], onDelete: Cascade)
  answerOption AnswerOption @relation("AnswerOption_ChosenIn", fields: [answerOptionId], references: [id], onDelete: Cascade)

  @@unique([attemptId, questionId], map: "AttemptAnswer_attemptId_questionId_key")
  @@index([answerOptionId])
}

model Purchase {
  id              String   @id @default(cuid())
  userId          String
  examId          String
  stripeSessionId String   @unique
  createdAt       DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  exam Exam @relation(fields: [examId], references: [id], onDelete: Cascade)

  @@unique([userId, examId])
}

model LabValue {
  id       String @id @default(cuid())
  name     String
  refRange String
  unit     String
  category String
}

model MediaAsset {
  id       String    @id @default(cuid())
  url      String    @unique
  kind     MediaKind
  alt      String?
  thumbUrl String?

  usedIn QuestionMedia[]
}

model QuestionMedia {
  questionId String
  mediaId    String
  order      Int    @default(0)

  question Question   @relation(fields: [questionId], references: [id], onDelete: Cascade)
  media    MediaAsset @relation(fields: [mediaId], references: [id], onDelete: Cascade)

  @@id([questionId, mediaId])
}

model EmailVerification {
  id         String    @id @default(cuid())
  userId     String
  newEmail   String?
  code       String
  expiresAt  DateTime
  consumedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, code])
  @@index([userId, newEmail, code])
}

model PasswordReset {
  id        String    @id @default(cuid())
  userId    String
  token     String    @unique
  expiresAt DateTime
  usedAt    DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, token])
}

model QuestionCase {
  id       String  @id @default(cuid())
  examId   String
  title    String
  vignette String?
  order    Int     @default(0)

  exam      Exam       @relation(fields: [examId], references: [id], onDelete: Cascade)
  questions Question[]

  @@index([examId, order])
}

model UserQuestionStat {
  userId        String
  questionId    String
  seenCount     Int       @default(0)
  wrongCount    Int       @default(0)
  lastWrongAt   DateTime?
  lastCorrectAt DateTime?
  updatedAt     DateTime  @updatedAt

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@id([userId, questionId])
  @@index([questionId])
  @@index([lastWrongAt])
}

model UserQuestionFlag {
  userId     String
  questionId String
  flaggedAt  DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@id([userId, questionId])
  @@index([questionId])
}

model QuestionStar {
  userId     String
  questionId String
  createdAt  DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@id([userId, questionId])
  @@index([questionId])
}

/**
 * ============ Tags ============
 */
model Tag {
  id       String  @id @default(cuid())
  name     String
  slug     String  @unique
  parentId String?
  parent   Tag?    @relation("TagHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children Tag[]   @relation("TagHierarchy")

  questionLinks QuestionTag[]

  @@index([parentId])
}

model QuestionTag {
  questionId String
  tagId      String

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  tag      Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([questionId, tagId])
  @@index([tagId])
}

/**
 * ============ Decks (explizite Pivot) ============
 */
model Deck {
  id          String   @id @default(cuid())
  userId      String
  title       String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  isAuto   Boolean       @default(false)
  autoType DeckAutoType?

  user  User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  items DeckItem[]

  // genau 1 Deck pro (userId, autoType); mehrere mit NULL (normale Decks) sind erlaubt
  @@unique([userId, autoType])
  @@index([userId])
}

model DeckItem {
  deckId     String
  questionId String
  order      Int      @default(0)
  addedAt    DateTime @default(now())

  deck     Deck     @relation(fields: [deckId], references: [id], onDelete: Cascade)
  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  // sorgt dafür, dass upsert({ where: { deckId_questionId: {…}}}) funktioniert
  @@id([deckId, questionId])
  @@index([questionId])
}

/**
 * ======= Spaced Repetition =======
 */
model ReviewItem {
  id         String   @id @default(cuid())
  userId     String
  questionId String
  dueAt      DateTime
  interval   Int      @default(1)
  ease       Float    @default(2.5)
  lapses     Int      @default(0)
  suspended  Boolean  @default(false)

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([userId, questionId])
  @@index([dueAt])
}
